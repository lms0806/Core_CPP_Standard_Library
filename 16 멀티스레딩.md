# 멀티스레딩

### 메모리 모델

- 멀티스레딩은 잘 정의된 메모리 모델을 토대로 만들었다. 이 메모리 모델은 다음과 같은 역할을 담당한다.
  - `어토믹 연산` : 인터럽트 없이 수행할 수 있는 연산
  - `연산의 부분 순서화` : 순서가 바뀌면 안되는 연산 시퀀스
  - `연산의 시각적 효과` : 공유 변수에 대한 연산이 다른 스레드에도 보이도록 보장하기
- C++ 메모리 모델은 토대가 되는 자바 메모리 모델과 비슷한 점이 많지만, C++에서는 순차 일관성을 깰 수 있다는 점이 다르다. 어토믹 연산의 디폴트 동작은 `순차 일관성`을 따른다.
- 순차 일관성은 다음 두 가지 사항을 보장한다.
  - 프로그램의 인스트럭션을 소스 코드에 나온 순서대로 수행하기
  - 모든 스레드에 대한 모든 연산의 전체 순서

### 어토믹 데이터 타입

- C++는 불 타입, 문자, 숫자, 포인터 등과 같은 간단한 어토믹 데이터 타입을 제공하며 `atomic`헤더에 정의돼 있다.
- `std::atomic` 템플릿을 이용하면 어토믹 데이터 타입을 직접 정의할 수 있지만, 몇 가지 제약 사항이 있다.
  - MyType과 MyType의 모든 기본 클래스에 대한 복제 대입 연산자와 MyType에서 static이 아닌 모든 맴버는 반드시 단순해야 한다.
  - MyType은 반드기 `가상 메서드`나 `기본 클래스`가 아니어야 한다.
  - MyType은 반드시 비트 단위로 복제할 수 있어야 하고 비교할 수 있어야 한다. 그래야 C 함수인 `memcpy`나 `memcmp`에서 사용할 수 있다.

### 스레드

- C++의 멀티스레딩 인터페이스를 사용하려면 `thread` 헤더를 인클루드 해야한다.

- ### 생성

  - `std::thread`는 실행 단위를 표현한다. 실행 단위는 스레드 생성과 동시에 시작하며, 작업 패키지를 콜러블 단위로 가져온다. 콜러블 단위는 함수일 수도 있고, 함수 오브젝트일 수도 있으며, 람다 함수일 수도 있다.

- ### 수명

  - 스레드를 생성했다면, 스레드의 수명 동안 관리해야 한다.
  - 생성된 스레드는 콜러블이 종료할 때 같이 끝난다. 이때 스레드 생성자는 스레드 t가 끝날 때까지 기다릴 수 있고(`t.join()`), 스레드와 분리할 수도 있다(`t.detach()`). `t.join()`이나 `t.detach()`가 실행되기 전에는 스레드 t가 조인 가능한 상태다.
  - 조인 가능한 스레드는 소멸자에서 `std::terminate` 익셉션을 호출해 프로그램을 종료시킨다.
  - 생성자와 분리된 스레드는 백그라운드에서 실행되기 때문에 흔히 `데몬 스레드`라고 부른다.

- ### 인수

  - `std::thread`는 가변 인수 템플릿이다. 복제 또는 레퍼런스를 통해 원하는 만큼 인수를 받을 수 있다.

- ### 연산
  - ## 스레드 연산
    |                 메서드                  |                              설명                              |
    | :-------------------------------------: | :------------------------------------------------------------: |
    |                t.join()                 |       스레드(t)에 있는 실행 단위가 끝날 떄까지 기다린다.       |
    |               t.detach()                |    생성된 스레드(t)를 생성자와 독립적으로 실행하게 만든다.     |
    |              t.joinable()               | 스레드(t)에 대해 join이나 detach를 호출할 수 있는지 검사한다.  |
    | t.get_id()와 std::this_thread::get_id() |                    스레드의 ID를 리턴한다.                     |
    |   std::thread::hardware_concurrency()   |         병렬로 실행할 수 있는 스레드 개수를 리턴한다.          |
    | std::this_thread::sleep_until(absTime)  | absTime으로 지정한 시각까지 스레드(t)를 슬립 상태로 전환한다.  |
    |  std::this_thread::sleep_for(relTime)   | relTime으로 지정한 시간 동안 스레드(t)를 슬립 상태로 전환한다. |
    |        std::this_thread::yield()        |     시스템에 있는 다른 스레드가 실행할 수 있도록 양보한다.     |
    |     t.swap(t2)와 std::swap(t1, t2)      |                       스레드를 맞바꾼다.                       |
    - 한 스레드(t)에 대해 t.join()이나 t.detach()는 단 한 번만 호출할 수 있다. 이 메서드를 여러번 호출하면 `std::system_error` 익셉션이 발생한다.
    - `std::thread::hardware_concurrency`는 코어의 개수를 리턴한다. 런타임이 코어 개수를 알 수 없다면 0을 리턴한다. `sleep_until`와 `sleep_for`는 시점이나 기간을 인수로 지정해야 한다.
    - 스데르들 복제할 수 없지만, 이동할 수는 있다. 맞바꾸기 연산은 가능하면 이동박식으로 처리한다.

### 공유 변수

- 여러 스레드가 변수 하나를 공유할 때는 변수에 접근하는 과정을 잘 조율해야 한다. 여기서 C++가 제공하는 뮤텍스와 락이 사용된다.

- ### 데이터 경쟁

  - 데이터 경쟁이란 최소 두 개 이상의 스레드가 공유 데이터 하나에 동시에 접근하는 상태를 말한다. 이때 적어도 한 스레드는 쓰기 작업을 수행한다. 이 상태에 빠진 프로그램의 동작은 예측할 수 없다.
  - 스트림은 스레드에 안전하다.

- ### 뮤텍스

  - 뮤텍스는 한 순간에 단 하나의 스레드만 `크리티컬 섹션(위험 부분, 임계 영역)`에 접근하도록 보장해준다.
  - 뮤텍스 m에 대해 `m.lock()`을 호출하면 크리티컬 섹션을 잠그고, `m.unlock()`을 호출하면 잠금을 해제한다.
  - 뮤텍스 종류

  ***

  |      메서드      | mutex | recursive_mutex | timed_mutex | recursive_timed_mutex | shared_timed_mutex |
  | :--------------: | :---: | :-------------: | :---------: | :-------------------: | :----------------: |
  |      m.lock      |   O   |        O        |      O      |           O           |         O          |
  |     m.unlock     |   O   |        O        |      O      |           O           |         O          |
  |    m.try_lock    |   O   |        O        |      O      |           O           |         O          |
  |  m.try_lock_for  |       |                 |      O      |           O           |         O          |
  | m.try_lock_until |       |                 |      O      |           O           |         O          |

- ### 데드락

  - 데드락(교착 상태)이란 여러 스데르가 서로 상대방이 리소스를 해제하기를 기다리면서 멈춘 상태
  - `m.unlock()` 호출을 생략하면 데드락을 쉽게 발생시킬 수 있다.
  - 1ms 정도의 아주 짧은 시간만으로도 충분히 데드락을 발생시킬 수 있다. 각 스레드가 서로 상대방 뮤텍스를 끝없이 기다리기 때문이다.

- ### 락

  - 뮤텍스는 자동으로 해제될 수 있도록 락 안에 캡슐화하는 것이 바람직하다. 락은 `RAII` 이디엄을 구현한 것이다. 뮤텍스의 수명을 락의 수명에 바인딩하기 때문이다.
  - C++11부터는 간단한 경우에 사용하는 `std::lock_guard`와 고급 활용 사례를 위한 `std::unique_lock`을 제공한다. 둘 다 `mutex` 헤더에 정의돼 있다.
  - `std::lock_guard`는 단 하나의 간단한 활용 사례에만 적용할 수 있다. 그러므로 생성자에서 뮤텍스를 바인딩했다가 소멸자에서 해제한다.
  - `std::unique_lock`은 `std::lock_guard`에 비해 사용법이 복잡하다. 하지만 `std::unique_lock`은 뮤텍스의 사용 여부에 관계없이 생성할 수 있고, 뮤텍스를 명시적으로 잠그거나 해제할 수 있으며, 뮤텍스를 잠그는 시간을 지연시킬 수 있다.
  - `std::unique_lock` 인터페이스

  ***

  |                               메서드                                |                       설명                        |
  | :-----------------------------------------------------------------: | :-----------------------------------------------: |
  |                              lk.lock()                              |              연계된 뮤텍스를 잠근다.              |
  |                      std::lock(lk1, lk2, ...)                       |  연계된 임의의 개수의 뮤텍스를 자동으로 잠근다.   |
  | lk.try_lock(), lk.try_lock_for(relTime), lk.try_lock_until(absTime) |          연계된 뮤텍스를 잠그려고 한다.           |
  |                            lk.release()                             | 뮤텍스를 해제한다. 뮤텍스는 잠긴 상태를 유지한다. |
  |                  lk.swap(lk2), std::swap(lk, lk2)                   |                  락을 맞바꾼다.                   |
  |                             lk.mutex()                              |      연계된 뮤텍스에 대한 포인터를 리턴한다.      |
  |                           lk.owns_lock()                            |       락에 연계된 뮤텍스가 있는지 확인한다.       |

  - 락을 가져오는 순서가 변경돼서 발생하는 데드락은 `std::atomic`으로 쉽게 해결할 수 있다.

- ### std::shared_lock

  - `std::shared_lock`의 인터페이스는 `std::unique_lock`과 같다. 또한 `std::shared_lock`은 여러 스레드가 동일한 잠김 상태의 뮤텍스를 공유하는 기능도 지원한다.
  - 이런 경우 `std::shared_lock`을 `std::shared_timed_mutex`와 함께 사용해야 한다. 하지만 여러 스레드가 `std::unique_lock`에 있는 동일한 `std::shared_timed_mutex`를 사용할 경우에는 단 하나의 스레드만 잠글 수 있다.

- ### 스레드에 안전한 초기화

  - C++은 스레드를 안전한 방식으로 초기화주는 방법들을 제공한다. 상수 표현식으 사용할 수도 있고, 블록 스코프가 지정된 스태틱 변수를 사용할 수도 있으며, `std::call_once` 함수에 `std::once::flag`를 지정하는 방법도 있다.
  - `상수 표현식`은 컴파일 시간에 초기화 된다. 근본적으로 스레드에 안전하다. 변수 앞에 constexpr이라는 키워드를 붙이면 상수 표현식을 만들 수 있다.

  ```
  struct MyDouble{
      constexpr MyDouble(double v) : val(v) {};
      constexpr double getValue() {return val;}
  private:
      double val
  }

  constexpr MyDouble myDouble(10.5);
  std::cout << myDouble.getValue(); // 10.5
  ```

  - `블록 안에 있는 스태틱 변수`를 정의할 떄 C++11 런타임은 그 변수가 스레드에 안전하게 초기화되도록 보장한다.

  ```
  void blockScope(){
      static int MySharedDataInt = 2011;
  }
  ```

  - `std::call_once`는 플래그인 `std::once::flag`와 콜러블이라는 두 가지 인수를 받는다. C++ 런타임은 `std::once_flag`를 이용해 주어진 콜러블이 단 한번만 실행되도록 보장한다.

### 스레드 로컬 데이터

- `thread_local` 키워드를 이용하면 `스레드 로컬 스토리지`라고도 부르는 `스레드 로컬 데이터`를 가질 수 있다. 그러면 스레드마다 데이터의 복제본을 갖게 된다.

### 상태 변수

- 상태 변수를 이용하면 메시지를 통해 스레드끼리 동기화할 수 있다. 스레드 변수는 `codition_variable` 헤더에 정의돼 있다.
- 한 스레드는 송신자 역할을 하고, 다른 스레드는 수신자 역할을 한다. 수신자는 송신자가 알림을 보낼 때까지 기다린다.
- 상태 변수(cv)에 대한 메서드

---

|              메서드               |                                  설명                                  |
| :-------------------------------: | :--------------------------------------------------------------------: |
|          cv.notify_one()          |                  대기 중인 스레드에게 알림을 보낸다.                   |
|          cv.notify_all()          |                대기 중인 스레드 모두에게 알림을 보낸다.                |
|        cv.wait(lock, ...)         |      `std::unique_lock`을 건 상태에서 알림이 올 때까지 기다린다.       |
|  cv.wait_for(lock, relTime, ...)  | `std::unique_lock`을 건 상태에서 지정된 지속 시간만큼 알림을 기다린다. |
| cv.wait_until(lock, absTime, ...) |   `std::unique_lock`을 건 상태에서 지정된 시간까지 알림을 기다린다.    |

- 송신자와 수신자는 락을 사용해야 한다.
- 송신자는 `std::lock_guard`만 사용해도 된다. 잠금과 잠금 해제를 한번씩만 호출하기 때문이다.
- 수신자는 `std::unique_lock`을 사용해야 한다. 뮤텍스를 잠그고 해제하는 경우가 많기 때문이다.

### 태스크

- 작업을 비동기식으로 수행하기 위한 수단으로 스레드뿐만 아니라 태스크도 제공한다. 태스크는 `future` 헤더에 정의돼 있다.
- 태스트는 `작업 패키지`로 매개변수를 지정할 수 있으며, `프로미스`와 `퓨처`라는 두 가지 컴포넌트로 구성돼 있다. 두 컴포넌트는 데이터 채널을 통해 서로 연결돼 있다.
- 태스크는 데이터 채널처럼 작동한다. 프로미스가 수행한 결과를 이 데이터 채널에 넣으면, 퓨처는 기다리고 있다가 결과가 들어오면 가져간다.

- ### 스레드 vs 태스크

  - 스레드를 생성한 스레드와 생성된 스레드가 서로 통신하려면 `공유 변수`를 사용해야 한다. 태스크는 `데이터 채널`로 통신한다.
  - 스레드를 생성한 스레드는 `join`을 호출해서 자식 스레드가 마칠 때까지 기다린다. `퓨처(fut)`는 `fut.get()`을 호출하는데, 결과가 올 때까지 멈추고 기다린다.
  - 생성된 스레드에서 익셉션이 발생하면 즉시 종료하고, 그 결과로 이를 생성한 스레드도 멈추면서 전체 프로세스를 끝낸다. 이때 익셉션을 `퓨처`가 처리하도록 `프로미스`가 익셉션을 퓨처에게 보낼 수 있다.
  - `프로미스`는 결과를 `여러 퓨처`로 전달할 수 있다. 전달 대상은 값일 수도 있고, 익셉션일 수도 있으며, 알림만 보낼 수 있다. `상태 변수보다는 태스크가 안전하다.`

- ### std::async

  - `std::async`는 비동기 함수 호출처럼 작동하며, 콜러블을 인수로 받는다.
  - `std::async`는 가변 인수 템플릿이다. 그래서 원하는 수만큼 인수를 받을 수 있다.
  - `std::async`는 `퓨처 오브젝트(fut)`를 리턴한다. 이 오브젝트는 ` fut.get``() `처럼 호출 결과를 가져오기 위한 핸들로 사용된다.
  - 옵션으로 `std::async`의 `구동 정책`을 지정할 수 있다. 이 구동 정책을 통해 `비동기 호출`을 같은 스레드에서 실행할지, 아니면 다른 스레드에서 실행할지를 명시적으로 지정할 수 있다.

- ### std::packaged_task

  - `std::packaged_task`를 이용하면 나중에 다른 스레드에서 실행할 콜러블에 대한 간단한 래퍼를 만들 수 있다. 이 방법은 다음과 같이 네 단계로 구성된다.
    - 1. 작업을 묶는다.
    ```
    std::packaged_task<int(int, int)> sumTask([](int a, int b) { return a + b});
    ```
    - 2. 퓨처를 생성한다.
    ```
    std::future<int> sumResult = sumTask.get_future();
    ```
    - 3. 계산을 수행한다.
    ```
    sumTask(2000, 11);
    ```
    - 4. 결과를 요청한다.
    ```
    sumResult.get();
    ```
  - `std::ppackaged_task`나 `std::future`를 별도 스레드로 옮긴다.

- ### std::promise와 std::future
  - `std::promise`와 `std::future` 쌍을 통해 태스크를 완전히 제어할 수 있다.
  - `프로미스(prom)`에서 제공하는 메서드
  ***
  |                   메서드                   |                             설명                              |
  | :----------------------------------------: | :-----------------------------------------------------------: |
  | prom.swap(prom2)와 std::swap(prom1, prom2) |                     프로미스를 맞바꾼다.                      |
  |             prom.get_future()              |                       퓨처를 리턴한다.                        |
  |            prom.set_value(val)             |                        값을 설정한다.                         |
  |           prom.set_exception(ex)           |                      익셉션을 설정한다.                       |
  |     prom.set_value_at_thread_exit(val)     |   값을 저장해서 프로미스가 종료할 때 사용할 수 있게 만든다.   |
  |   prom.set_exception_at_thread_exit(ex)    | 익셉션을 저장해서 프로미스가 종료할 때 사용할 수 있게 만든다. |
  - 프로미스가 값이나 익셉션을 한 번 이상 설정하면 `std::future_error` 익셉션이 발생한다.
  - `퓨처(fut)`에서 제공하는 메서드
  ***
  |         메서드          |                                     설명                                      |
  | :---------------------: | :---------------------------------------------------------------------------: |
  |       fut.share()       |                        std::shared_future를 리턴한다.                         |
  |        fut.get()        |          결과를 리턴한다. 결과는 값일 수도 있고 익셉션일 수도 있다.           |
  |       fut.valid()       | 결과에 접근할 수 있는지 검사한다. fut.get()을 호출한 후라면 false를 리턴한다. |
  |       fut.wait()        |                         결과가 나올 때까지 가다린다.                          |
  |  fut.wait_for(relTime)  |                  결과가 나올 때까지(relTime 동안) 기다린다.                   |
  | fut.wait_until(absTime) |                   결과가 나올 때까지(absTime까지) 기다린다.                   |
  - 결과에 대해 `퓨처(fut)`를 한 번 이상 요청하면 `std::future_error` 익셉션이 발생한다.
  - `퓨처`는 `fut.share()`를 호출해서 `공유 퓨처`를 생성한다. 공유 퓨처는 프로미스에 연결되며 독립적으로 결과를 요청할 수 있다.

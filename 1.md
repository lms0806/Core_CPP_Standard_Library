# 표준 라이브러리

## 개요

- ### 유틸리티
  - 유틸리티 라이브러리는 여러 문맥에 두루 활용할 수 있는 범용 기능을 모아둔 라이브러리
  - `std::bind`, `std::function`, `std::pari`, `std::tuple`, `std::ref`, `std::cref`가 있음
    - `std::bind` : 기존 함수를 토대로 새로운 함수를 쉽게 만들 수 있음
    - `std::function` : std::bin으로 만든 함수를 나중에 호출하기 위해 변수에 바인딩할 때 사용
    - `std::pair`나 `std::tuple`을 이용하면 임의의 길이로 된 이형 페어나 튜플을 생성할 수 있음
    - `std::ref` : 변수에 대한 레퍼런스 래퍼 오브젝트를 생성함
    - `std::cref` : const 래퍼런스를 생성한다.
  - 핵심 : c++에서 메모리를 동적으로 관리할 수 있게 해주는 스마트 포인터
  - 단독 소유권은 `std::unique_ptr`로, 공유 소유권은 `std::shared_ptr`로 표현한다.
  - `std::shared_ptr`는 레퍼런스 수를 세는 방식으로 리소스를 관리함
  - `std::weak_ptr`는 레퍼런스 카운팅의 고질적인 문제인 `std::shared_ptr` 사이의 순환 의존성을 깨는 데 도움이 됨
  - 타입 트레이트 라이브러리는 컴파일 시간에 타입 정보를 검사하고, 비교하고, 조작하는 데 사용됨
  - 시간 라이브러리는 C++에 새롭게 추가된 멀티스레딩 기능에서 중요한 역할을 하며, 성능 측정에도 유용함
- ### 표준 템플릿 라이브러리(STL)
  - 세 가지 요소로 컨테이너, 컨테이너에 대해 실행되는 알고리즘, 컨테이너와 알고리즘을 연결하는 반복자로 이루어져 있다.
  - 추상화된 제네릭 프로그래밍을 통해 알고리즘과 컨테이너를 고유한 방식으로 결합할 수 있음
  - C++ 표준 라이브러리는 다양한 종류의 컨테이너를 제공하며, 크게 순차와 연관으로 나눌 수 있음
  - 순차 컨테이너에 해당하는 컨테이너마다 고유한 용도가 있으나, `std::vector`로 충분하다.
    - `std::vector`는 크기를 동적으로 조절할 수 있고, 메모리를 자동으로 관리해주며, 성능도 좋다.
    - `std::array`는 순차 컨테이너 중 유일하게 크기를 실행 시간에 조정할 수 없다. 메모리 사용량을 최소화하여 성능을 최적화한 것이다.
    - `std::vector`는 맨 뒤에 새로운 원소를 추가하는 반면, `std::deque`는 원소를 맨 앞에도 추가할 수 있음
    - `std::list`는 이중 연결 리스트, `std::forward_list`는 단일 연결 리스트 이다.
  - 연관 컨테이너는 키-값 쌍으로 구성된 컨테이너로, 주어진 키에 대해 값을 제공한다. C++은 8가지 연관 컨테이너를 제공하며, 정렬 연관 컨테이너와 비정렬 연관 컨테이너로 분류한다.
    - 정렬 컨테이너는 키를 기준으로 정렬하며 `std::set`, `std::map`, `std::multiset`, `std::multimap` 등이 있다.
      - `std::set`은 키에 연관된 값이 없고, `std::map`은 키에 연관된 값이 있음
      - `std:map`은 키가 고유하지만, `std:multimap`은 키가 중복될 수 있다.
      - 정렬 컨테이너의 접근 시간은 원소의 개수에 대해 로그 함수로 증가한다.
    - 비정렬 컨테이너는 `std::unordered_set`, `std::unordered_map`, `std:unordered_multiset`, `std::unordered_multimap` 등이 있다.
      - 비정렬 컨테이너의 접근 시간은 크기와 관계가 없이 일정하다.
    - 컨테이너 어댑터는 순차 컨테이너에 대한 간편한 인터페이스를 제공한다. C++은 `std::stack`, `std::deque`, `std::priority_queue`를 제공함
    - 반복자는 컨테이너와 알고리즘을 연결해 준다. 컨테이너에 의해 생성되며 범용 포인터로 구성된다.
    - STL은 알고리즘을 100개 이상(순차, 병렬, 병렬 및 벡터 중에서 원하는 실행 정책에 따라 거의 모든 알고리즘) 제공한다.
      - 범위는 시작을 가리키는 `시작 반복자`, 끝을 정하는 `끝 반복자`로 지정함
      - 끝 반복자는 범위 끝에 해당하는 원소가 아니라, 그 다음 지점을 가리킴에 주의해야 한다.
- ### 수치 연산
  - 무작위수 라이브러리와 C에서 물려받은 수학 함수 라이브러리가 있다.
    - 무작위수 라이브러리는 `무작위수 생성기`와 생성된 무작위수의 분포에 대한 것이다.
    - 무작위수 생성기는 최댓값과 최솟값 사이에 있는 일련의 무작위 수를 생성한다.
    - 표준 수학 함수로는 로그함수, 지수 함수, 삼각 함수 등이 있다.
- ### 텍스트 처리
  - 스트링과 정규 표현식에 관련된 두 가지 강력한 라이브러리를 제공한다.
    - `std::string`은 텍스트 분석과 수정에 관련된 메서드를 다양하게 제공한다. C의 스트링을 좀 더 쉽고 안전하게 사용하도록 확장한 것이다.
    - 문자에 대한 `std::vector`와 공통점이 많기 때문에 STL 알고리즘을 `std::string`에도 사용할 수 있다.
    - `std::string`과 달리 `std::string_view`는 복사 연산이 가볍다. `std::string`에 대한 비소유 레퍼런스다.
- ### 입력과 출력
  - `추출 연산자` >>는 입력 스트림에서 서식이 있거나 없는 데이터를 읽는다.
  - `추가 연산자` <<는 출력 스트림에 데이터를 쓴다.
  - 데이터의 서식은 조작자(매니퓰레이터)로 지정한다.
  - 스트림 클래스는 계층 구조가 정교하다. 그 중 2가지 클래스가 중요하다.
    - `스트링 스트림`은 스트링과 스트림을 다룬다.
    - `파일 스트림`은 파일을 쉽게 읽고 쓸 수 있다.
- ### 멀티스레딩
  - C++11부터 멀티스레딩 라이브러리가 표준으로 들어왔다. 이 라이브러리는 어토믹 변수, 스레드, 락과 상태 변수 같은 기본 구성 요소로 구성된다.
  - C++11부터 `태스크`라는 고급 추상화를 제공한다.
  - `스레드`는 포그라운드나 백그라운드에서 구동할 수 있고, 복제나 레퍼런스 방식으로 데이터를 받을 수 있다.
  - `뮤텍스`나 `락(잠금 장치)`을 이용해 다양한 방식으로 스데르를 제어하여 처리할 수 있지만, 데이터를 초기화하는 부분을 보호하는 것만으로도 전체 수명 동안 불변 상태를 유지하기 때문에 이 정도로 충분한 경우가 많다.
  - 변수를 `스레드-로컬`로 선언하면 스레드는 그 변수의 복제본을 받아오기 때문에 충돌이 발생하지 않는다.
  - 상태 변수는 송신자-수신자 워크플로를 구현하기 위한 전통적인 기법이다. 송신자가 수신자에게 작업이 끝났다고 알려주면 수신자는 작업을 시작하는 개념이다.
  - `스레드`는 프로그래머가 직접 생성하는데 반해, `태스크`는 C++ 런타임이 내부적으로 생성한다.

### 라이브러리 활용

- ### 헤더 파일 인클루드하기

  - 전처리기는 #include로 지정한 파일을 추가(인클루드) 한다.

  ```
  #include<iostream>
  #include<vector>
  ```

- ### 네임스페이스 지정하기
  - 긴 이름으로 지정할 때는 원래 정의된 형태 그대로, 네임스페이스마다 `스코프 지정 연산자`인 ::을 붙여서 작성해야 한다.
  ```
  #include<iostream>
  #include<chrono>
  ...
  std::count << "Hello world:" << std::endl;
  auto timeNow = std::chrono::system_clock::now();
  ```
  - `using 선언`과 `using 디렉티브`로 이름을 사용할 수 있다. using 선언을 사용하면 그 선언문에 적용된 스코프에 이름이 추가된다.
  ```
  #include<iostream>
  #include<chrono>
  ...
  using std::count;
  using std::endl;
  using std::chrono:;system_clock;
  ...
  count << "Hello world:" << endl;
  auto timeNow = now();
  ```
  - using을 선언하면 다음과 같은 현상이 발생한다.
    - 한 스코프에 같은 이름을 선언하면 모호한 룩업과 이에 따른 컴파일 에러가 발생한다.
    - 상위 스코프에 같은 이름이 선언되어 있으면 using 선언에 의해 가려진다.
  - `using 디렉티브`를 이용하면 네임스페이스 이름을 짧게 사용할 수 있다.
  ```
  #include<iostream>
  #include<chrono>
  ...
  using namespace std;
  ...
  count << "Hello world:" << endl;
  auto timeNow = chrono::system_clock::now();
  ```
  - using 디렉티브는 스코프에 이름을 새로 추가하지 않고 그 이름에 접근만 할 수 있게 만들어 다음과 같은 현상이 발생한다.
    - 한 스코프에 같은 이름을 선언하면 모호한 룩업과 이에 따른 컴파일 에러가 발생
    - 상위 스코프에 같은 이름이 선언되어 있으면 using 선언에 의해 가려짐
    - 다른 네임스페이스에 동일한 이름이 있거나 네임스페이스에 있는 이름이 글로벌 스코프에 있는 이름을 가리면, 모호한 룩업과 이에 따른 컴파일 에러가 발생
  - `네임스페이스 앨리어스`는 네임스페이스에 대한 동의어를 정의한다. 긴 네임스페이스나 중첩된 네임스페이스 대신 이렇게 앨리어스를 사용하면 편할 때가 많다.
  ```
  #include<chrono>
  ...
  namespace sysClock = std::chrono::system_clock;
  auto nowFirst = sysClock::now();
  auto nowSecond = std::chrono::system_clock::now();
  ```
  - now 함수를 공식 네임스페이스로 가리킬 수 있지만, 네임스페이스 앨리어스로 가리킬 수도 있다. 네임스페이스 앨리어스를 사용할 때는 다른 이름을 가리지 않도록 주의해야함
- ### 실행 파일 생성하기
- 라이브러리를 명시적으로 링크할 일은 거의 없지만, 플랫폼마다 다를 수 있다.

```
g++ -std=c++14 thread.cpp -o thread -pthread
```
